# 2025.02.06 (목)

## 데일리 스크럼
### 오늘 할 일
- 키워드 정리
- 2차 과제 시작

## 수업 키워드 정리
> ### **동시성, 스케줄러, 병렬성**

### 동시성 ↔ 병렬성

|  | Concurrency | Parallelism |
| --- | --- | --- |
| 실행 방식 | CPU가 컨텍스트 스위칭으로 빠르게 <br> 작업을 전환하며 여러 작업이 동시에 <br> 실행되는 것처럼 보이게 함 | 다중 코어 CPU나 다중 프로세스를 <br> 활용해 실제로 여러 작업 동시에 실행함 |
| 실행 환경 | 싱글 코어에서도 가능 | 멀티 코어 |
| 핵심 | 빠른 문맥 전환 | 여러 개의 코어 활용 |
| 장점 | 시스템 자원을 효율적으로 활용 | 시간 절약, 생산성 극대화 |
| 활용 분야 | 웹 서버의 요청 처리 | 실시간 처리 (게임, 스트리밍), <br> 대규모 데이터 처리 (머신러닝) |

### 스케쥴러

> 한정적인 메모리를 효율적으로 사용하도록 작업을 선택하는 기술

✅ 시스템 성능을 최적화하는게 궁극적 목표

- 시스템 성능
    - CPU 이용률 최대화
    - 처리량 최대화
    - 총 처리시간 최소화
    - 대기시간 최소화
    - 응답시간 최소화

### 스케쥴링 방식

#### 선점형 스케쥴링

> 실행 중인 프로세스가 강제적으로 실행권을 빼앗기는 방식

- 장점 : 공정성
- 단점 : 컨텍스트 스위칭에 의한 오버헤드가 크다.

`RR (Round-Robin)`

- 모든 프로세스에 CPU 할당 시간을 부여하는 방식
- 할당 시간이 너무 길 때 → 중요한 작업의 순위가 밀릴 수 있음
- 할당 시간이 너무 짧을 때 → 컨텍스트 스위칭 오버헤드 발생

`선점 우선순위`

- 우선순위가 높은 순으로 번갈아가며 CPU에 할당
- Aging에 따라 우선순위가 바뀌면 현재 프로세스가 실행권을 잃을 수 있음

`다단계 피드백 큐`

- 프로세스를 우선순위에 따라 그룹화하고, 각각 다른 큐를 사용하는 방식
- Aging을 통해 기아현상 해결

#### 비선점형 스케쥴링

> CPU를 선점한 프로세스가 자발적으로 실행권을 내려놓는 방식

- 장점 : 공정성, 컨텍스트 스위칭에 의한 오버헤드 적음
- 단점 : 기아 현상(Starvation) 발생 가능

`CFS (First Come First Served)`

- 큐에 도착한대로 CPU에 할당

`SJF (Shortest Job First)`

- 실행시간이 짧은 작업 먼저 CPU에 할당 → 기아상태 발생 가능

`Priority Scheduling`

- 우선순위가 높은 순으로 CPU에 할당

`HRRN (Highest Response Ratio Next)`

- 응답률 = (대기시간 + CPU 요구량) / CPU 요구량
- 응답률이 높은 순으로 CPU에 할당

#### 콘보이 현상
    
작업시간이 긴 프로세스를 우선적으로 처리하여 평균 대기 시간이 높아지는 비효율적인 작업
    
#### Starvation
    
순위가 밀려 할당을 계속 받지 못하는 프로세스가 생기는 상태
    
#### Aging
    
기아상태 해결 방법. 실행되지 않은 프로세스의 우선순위를 시간이 지날 때마다 높이는 방법
    

### 프로세스 스케쥴링과 스레드 스케쥴링의 차이점에 대해서 설명해주세요

|  | Process Scheduling | Thread Scheduling |
| --- | --- | --- |
| 스케쥴링 대상 | 실행 중인 여러 프로세스 | 하나의 프로세스 내 여러 스레드 |
| 운영 주체 | 운영체제 (커널) | 커널 또는 유저 |
| 컨텍스트 스위칭 비용 | 높음 (레지스터 저장.복구 등 필요) | 낮음 (레지스터만 교체) |
| 스위칭 속도 | 느림 | 빠름 (메모리 주소 관련 처리 불필요) |
| 대표적 스케쥴링 방식 | FCFS, SJF, RR, Priority | Preemptive Scheduling, Time-Slicing |

### 컨텍스트 스위칭

> 작업 중이던 프로세스나 스레드의 상태를 저장하고 다른 프로세스나 스레드를 로드하는 과정

- 부정적인 영향
    - 오버헤드가 증가하여 성능이 저하될 수 있음

---

`경량 스레드 모델`

: 기존 스레드 모델보다 실행 단위를 더 작게 나눈 모델

- 탄생 배경 : 요청량이 급격하게 증가하는 서버 환경 → 필요한 스레드 수 증가 → 스레드 수의 한계 도달 + 컨텍스트 스위칭 비용 크게 증가
- 동작 방식 : `플랫폼 스레드` 위에서 여러 `가상 스레드`가 번갈아 가며 실행된다.
- 장점 : 컨텍스트 스위칭 비용과 Blocking 타임을 낮출 수 있다.
- 대표적 모델 : Go goroutine / Kotlin coroutine / Java Virtual Thread

### 스레드 풀

> 적절한 개수의 스레드를 미리 생성하여 관리하는 기법

- 사용 이유 : 많은 개수의 스레드가 요구될 때
- 장점 : 스레드 생성 및 삭제에 드는 비용을 줄여준다.
- 단점 : 필요 이상의 스레드를 만들어 두면 메모리가 낭비된다.

## PS

### [백준 28447] [실버 2] 마라탕 재료 고르기

`브루트포스 + 백트래킹`을 이용해 Combination을 모두 구하는 법을 익혔다. 

## 회고

부지런히 한다고 했는데 키워드 정리랑 PS만 하면 시간이 다 간다.

마크다운으로 글을 적는게 익숙하지 않아 TIL 작성이 쉽지 않다 😂